use serde::{Deserialize, Serialize};

use super::item::Item;

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Response {
    /// The unique ID of the response.
    pub id: String,
    /// The object type, must be "realtime.response".
    pub object: String,
    /// The status of the response.
    pub status: ResponseStatus,
    /// Additional details about the status.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_details: Option<ResponseStatusDetail>,
    /// The list of output items generated by the response.
    pub output: Vec<Item>,
    /// Usage statistics for the response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<Usage>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Usage {
    pub total_tokens: u32,
    pub input_tokens: u32,
    pub output_tokens: u32,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ResponseStatus {
    InProgress,
    Completed,
    Failed,
    Cancelled,
    Incomplete,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(tag = "type")]
pub enum ResponseStatusDetail {
    #[serde(rename = "incomplete")]
    Incomplete { reason: IncompleteStatusDetail },
    #[serde(rename = "failed")]
    Failed { error: Option<FailedStatusDetail> },
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum IncompleteStatusDetail {
    Interruption,
    MaxOutputTokens,
    ContentFilter,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct FailedStatusDetail {
    pub code: String,
    pub message: String,
}
