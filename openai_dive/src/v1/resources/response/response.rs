use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use crate::v1::resources::shared::{ReasoningEffort, Usage};

use super::{
    items::{FileSearchToolCall, FunctionToolCall, Reasoning, WebSearchToolCall},
    shared::{Annotation, ResponseFormat, ResponseTool, ResponseToolChoice, TruncationStrategy},
};

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ResponseObject {
    /// Unix timestamp (in seconds) of when this Response was created.
    pub created_at: u32,
    /// An error object returned when the model fails to generate a Response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ResponseError>,
    /// Unique identifier for this Response.
    pub id: String,
    /// Details about why the response is incomplete.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incomplete_details: Option<IncompleteDetails>,
    /// Inserts a system (or developer) message as the first item in the model's context.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instruction: Option<String>,
    /// An upper bound for the number of tokens that can be generated for a response, including visible output tokens and reasoning tokens.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_output_tokens: Option<u32>,
    /// Set of 16 key-value pairs that can be attached to an object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    /// Model ID used to generate the response.
    pub model: String,
    /// The object type of this resource - always set to response.
    pub object: String,
    /// An array of content items generated by the model.
    pub output: Vec<ResponseOutput>,
    /// Whether to allow the model to run tool calls in parallel.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parallel_tool_calls: Option<bool>,
    /// The unique ID of the previous response to the model.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_response_id: Option<String>,
    /// Configuration options for reasoning models.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning: Option<ResponseReasoning>,
    /// The status of the response generation.
    pub status: ReasoningStatus,
    /// What sampling temperature to use, between 0 and 2.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f32>,
    /// Configuration options for a text response from the model.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<ResponseText>,
    /// How the model should select which tool (or tools) to use when generating a response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_choice: Option<ResponseToolChoice>,
    /// An array of tools the model may call while generating a response.
    pub tools: Vec<ResponseTool>,
    /// An alternative to sampling with temperature.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f32>,
    /// The truncation strategy to use for the model response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truncation: Option<TruncationStrategy>,
    /// Represents token usage details.
    pub usage: Usage,
    /// A unique identifier representing your end-user.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ResponseError {
    /// The error code for the response.
    pub code: String,
    /// A human-readable description of the error.
    pub message: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct IncompleteDetails {
    /// The reason why the response is incomplete.
    pub reason: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ResponseOutput {
    Message(OutputMessage),
    #[serde(rename = "function_call")]
    FunctionToolCall(FunctionToolCall),
    #[serde(rename = "file_search_call")]
    FileSearchToolCall(FileSearchToolCall),
    #[serde(rename = "web_search_call")]
    WebSearchToolCall(WebSearchToolCall),
    // #[serde(rename = "computer_call")]
    // ComputerToolCall(ComputerToolCall),
    Reasoning(Reasoning),
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct OutputMessage {
    pub id: String,
    pub role: Role,
    pub status: MessageStatus,
    pub content: Vec<OutputContent>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ResponseReasoning {
    /// Constrains effort on reasoning for reasoning models.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub effort: Option<ReasoningEffort>,
    // A summary of the reasoning performed by the model.
    // pub generate_summary: Option<ReasoningSummary>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ResponseText {
    /// An object specifying the format that the model must output.
    pub format: ResponseFormat,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum ReasoningSummary {
    Concise,
    Detailed,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ReasoningStatus {
    Completed,
    Failed,
    InProgress,
    Incomplete,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    User,
    System,
    Assistant,
    Developer,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum MessageStatus {
    InProgress,
    Completed,
    Incomplete,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(tag = "type")]
pub enum OutputContent {
    #[serde(rename = "output_text")]
    Text {
        text: String,
        annotations: Vec<Annotation>,
    },
    #[serde(rename = "refusal")]
    Refusal { refusal: String },
}
